package cli

// Code generated by go generate; DO NOT EDIT.

import (
	"net"
	"time"

	"github.com/spf13/pflag"
)

var _ Flag = &BoolFlag{}

// BoolFlag is used to define a pflag.FlagSet.BoolP flag.
type BoolFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    bool
	Required bool
}

// Apply implements Flag.
func (f *BoolFlag) Apply(fs *pflag.FlagSet) {
	fs.BoolVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *BoolFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *BoolFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *BoolFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *BoolFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *BoolFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *BoolFlag) IsRequired() bool {
	return f.Required
}

// Bool returns the bool value of the flag with the specified name.
func (c *Context) Bool(name string) bool {
	value := c.lookup(name).GetValue()

	v, ok := value.(bool)
	if !ok {
		panic(typeMismatchErr(name, "bool", value))
	}

	return v
}

var _ Flag = &BoolSliceFlag{}

// BoolSliceFlag is used to define a pflag.FlagSet.BoolSliceP flag.
type BoolSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []bool
	Required bool
}

// Apply implements Flag.
func (f *BoolSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.BoolSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *BoolSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *BoolSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *BoolSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *BoolSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *BoolSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *BoolSliceFlag) IsRequired() bool {
	return f.Required
}

// BoolSlice returns the []bool value of the flag with the specified name.
func (c *Context) BoolSlice(name string) []bool {
	value := c.lookup(name).GetValue()

	v, ok := value.([]bool)
	if !ok {
		panic(typeMismatchErr(name, "[]bool", value))
	}

	return v
}

var _ Flag = &BytesBase64Flag{}

// BytesBase64Flag is used to define a pflag.FlagSet.BytesBase64P flag.
type BytesBase64Flag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []byte
	Required bool
}

// Apply implements Flag.
func (f *BytesBase64Flag) Apply(fs *pflag.FlagSet) {
	fs.BytesBase64VarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *BytesBase64Flag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *BytesBase64Flag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *BytesBase64Flag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *BytesBase64Flag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *BytesBase64Flag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *BytesBase64Flag) IsRequired() bool {
	return f.Required
}

// BytesBase64 returns the []byte value of the flag with the specified name.
func (c *Context) BytesBase64(name string) []byte {
	value := c.lookup(name).GetValue()

	v, ok := value.([]byte)
	if !ok {
		panic(typeMismatchErr(name, "[]byte", value))
	}

	return v
}

var _ Flag = &BytesHexFlag{}

// BytesHexFlag is used to define a pflag.FlagSet.BytesHexP flag.
type BytesHexFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []byte
	Required bool
}

// Apply implements Flag.
func (f *BytesHexFlag) Apply(fs *pflag.FlagSet) {
	fs.BytesHexVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *BytesHexFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *BytesHexFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *BytesHexFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *BytesHexFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *BytesHexFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *BytesHexFlag) IsRequired() bool {
	return f.Required
}

// BytesHex returns the []byte value of the flag with the specified name.
func (c *Context) BytesHex(name string) []byte {
	value := c.lookup(name).GetValue()

	v, ok := value.([]byte)
	if !ok {
		panic(typeMismatchErr(name, "[]byte", value))
	}

	return v
}

var _ Flag = &DurationFlag{}

// DurationFlag is used to define a pflag.FlagSet.DurationP flag.
type DurationFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    time.Duration
	Required bool
}

// Apply implements Flag.
func (f *DurationFlag) Apply(fs *pflag.FlagSet) {
	fs.DurationVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *DurationFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *DurationFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *DurationFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *DurationFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *DurationFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *DurationFlag) IsRequired() bool {
	return f.Required
}

// Duration returns the time.Duration value of the flag with the specified name.
func (c *Context) Duration(name string) time.Duration {
	value := c.lookup(name).GetValue()

	v, ok := value.(time.Duration)
	if !ok {
		panic(typeMismatchErr(name, "time.Duration", value))
	}

	return v
}

var _ Flag = &DurationSliceFlag{}

// DurationSliceFlag is used to define a pflag.FlagSet.DurationSliceP flag.
type DurationSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []time.Duration
	Required bool
}

// Apply implements Flag.
func (f *DurationSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.DurationSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *DurationSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *DurationSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *DurationSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *DurationSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *DurationSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *DurationSliceFlag) IsRequired() bool {
	return f.Required
}

// DurationSlice returns the []time.Duration value of the flag with the specified name.
func (c *Context) DurationSlice(name string) []time.Duration {
	value := c.lookup(name).GetValue()

	v, ok := value.([]time.Duration)
	if !ok {
		panic(typeMismatchErr(name, "[]time.Duration", value))
	}

	return v
}

var _ Flag = &Float32Flag{}

// Float32Flag is used to define a pflag.FlagSet.Float32P flag.
type Float32Flag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    float32
	Required bool
}

// Apply implements Flag.
func (f *Float32Flag) Apply(fs *pflag.FlagSet) {
	fs.Float32VarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Float32Flag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Float32Flag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Float32Flag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Float32Flag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Float32Flag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Float32Flag) IsRequired() bool {
	return f.Required
}

// Float32 returns the float32 value of the flag with the specified name.
func (c *Context) Float32(name string) float32 {
	value := c.lookup(name).GetValue()

	v, ok := value.(float32)
	if !ok {
		panic(typeMismatchErr(name, "float32", value))
	}

	return v
}

var _ Flag = &Float32SliceFlag{}

// Float32SliceFlag is used to define a pflag.FlagSet.Float32SliceP flag.
type Float32SliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []float32
	Required bool
}

// Apply implements Flag.
func (f *Float32SliceFlag) Apply(fs *pflag.FlagSet) {
	fs.Float32SliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Float32SliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Float32SliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Float32SliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Float32SliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Float32SliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Float32SliceFlag) IsRequired() bool {
	return f.Required
}

// Float32Slice returns the []float32 value of the flag with the specified name.
func (c *Context) Float32Slice(name string) []float32 {
	value := c.lookup(name).GetValue()

	v, ok := value.([]float32)
	if !ok {
		panic(typeMismatchErr(name, "[]float32", value))
	}

	return v
}

var _ Flag = &Float64Flag{}

// Float64Flag is used to define a pflag.FlagSet.Float64P flag.
type Float64Flag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    float64
	Required bool
}

// Apply implements Flag.
func (f *Float64Flag) Apply(fs *pflag.FlagSet) {
	fs.Float64VarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Float64Flag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Float64Flag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Float64Flag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Float64Flag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Float64Flag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Float64Flag) IsRequired() bool {
	return f.Required
}

// Float64 returns the float64 value of the flag with the specified name.
func (c *Context) Float64(name string) float64 {
	value := c.lookup(name).GetValue()

	v, ok := value.(float64)
	if !ok {
		panic(typeMismatchErr(name, "float64", value))
	}

	return v
}

var _ Flag = &Float64SliceFlag{}

// Float64SliceFlag is used to define a pflag.FlagSet.Float64SliceP flag.
type Float64SliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []float64
	Required bool
}

// Apply implements Flag.
func (f *Float64SliceFlag) Apply(fs *pflag.FlagSet) {
	fs.Float64SliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Float64SliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Float64SliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Float64SliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Float64SliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Float64SliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Float64SliceFlag) IsRequired() bool {
	return f.Required
}

// Float64Slice returns the []float64 value of the flag with the specified name.
func (c *Context) Float64Slice(name string) []float64 {
	value := c.lookup(name).GetValue()

	v, ok := value.([]float64)
	if !ok {
		panic(typeMismatchErr(name, "[]float64", value))
	}

	return v
}

var _ Flag = &IPFlag{}

// IPFlag is used to define a pflag.FlagSet.IPP flag.
type IPFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    net.IP
	Required bool
}

// Apply implements Flag.
func (f *IPFlag) Apply(fs *pflag.FlagSet) {
	fs.IPVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IPFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IPFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IPFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IPFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IPFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IPFlag) IsRequired() bool {
	return f.Required
}

// IP returns the net.IP value of the flag with the specified name.
func (c *Context) IP(name string) net.IP {
	value := c.lookup(name).GetValue()

	v, ok := value.(net.IP)
	if !ok {
		panic(typeMismatchErr(name, "net.IP", value))
	}

	return v
}

var _ Flag = &IPMaskFlag{}

// IPMaskFlag is used to define a pflag.FlagSet.IPMaskP flag.
type IPMaskFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    net.IPMask
	Required bool
}

// Apply implements Flag.
func (f *IPMaskFlag) Apply(fs *pflag.FlagSet) {
	fs.IPMaskVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IPMaskFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IPMaskFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IPMaskFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IPMaskFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IPMaskFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IPMaskFlag) IsRequired() bool {
	return f.Required
}

// IPMask returns the net.IPMask value of the flag with the specified name.
func (c *Context) IPMask(name string) net.IPMask {
	value := c.lookup(name).GetValue()

	v, ok := value.(net.IPMask)
	if !ok {
		panic(typeMismatchErr(name, "net.IPMask", value))
	}

	return v
}

var _ Flag = &IPNetFlag{}

// IPNetFlag is used to define a pflag.FlagSet.IPNetP flag.
type IPNetFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    net.IPNet
	Required bool
}

// Apply implements Flag.
func (f *IPNetFlag) Apply(fs *pflag.FlagSet) {
	fs.IPNetVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IPNetFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IPNetFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IPNetFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IPNetFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IPNetFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IPNetFlag) IsRequired() bool {
	return f.Required
}

// IPNet returns the net.IPNet value of the flag with the specified name.
func (c *Context) IPNet(name string) net.IPNet {
	value := c.lookup(name).GetValue()

	v, ok := value.(net.IPNet)
	if !ok {
		panic(typeMismatchErr(name, "net.IPNet", value))
	}

	return v
}

var _ Flag = &IPSliceFlag{}

// IPSliceFlag is used to define a pflag.FlagSet.IPSliceP flag.
type IPSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []net.IP
	Required bool
}

// Apply implements Flag.
func (f *IPSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.IPSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IPSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IPSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IPSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IPSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IPSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IPSliceFlag) IsRequired() bool {
	return f.Required
}

// IPSlice returns the []net.IP value of the flag with the specified name.
func (c *Context) IPSlice(name string) []net.IP {
	value := c.lookup(name).GetValue()

	v, ok := value.([]net.IP)
	if !ok {
		panic(typeMismatchErr(name, "[]net.IP", value))
	}

	return v
}

var _ Flag = &IntFlag{}

// IntFlag is used to define a pflag.FlagSet.IntP flag.
type IntFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    int
	Required bool
}

// Apply implements Flag.
func (f *IntFlag) Apply(fs *pflag.FlagSet) {
	fs.IntVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IntFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IntFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IntFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IntFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IntFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IntFlag) IsRequired() bool {
	return f.Required
}

// Int returns the int value of the flag with the specified name.
func (c *Context) Int(name string) int {
	value := c.lookup(name).GetValue()

	v, ok := value.(int)
	if !ok {
		panic(typeMismatchErr(name, "int", value))
	}

	return v
}

var _ Flag = &Int32Flag{}

// Int32Flag is used to define a pflag.FlagSet.Int32P flag.
type Int32Flag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    int32
	Required bool
}

// Apply implements Flag.
func (f *Int32Flag) Apply(fs *pflag.FlagSet) {
	fs.Int32VarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Int32Flag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Int32Flag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Int32Flag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Int32Flag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Int32Flag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Int32Flag) IsRequired() bool {
	return f.Required
}

// Int32 returns the int32 value of the flag with the specified name.
func (c *Context) Int32(name string) int32 {
	value := c.lookup(name).GetValue()

	v, ok := value.(int32)
	if !ok {
		panic(typeMismatchErr(name, "int32", value))
	}

	return v
}

var _ Flag = &Int32SliceFlag{}

// Int32SliceFlag is used to define a pflag.FlagSet.Int32SliceP flag.
type Int32SliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []int32
	Required bool
}

// Apply implements Flag.
func (f *Int32SliceFlag) Apply(fs *pflag.FlagSet) {
	fs.Int32SliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Int32SliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Int32SliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Int32SliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Int32SliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Int32SliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Int32SliceFlag) IsRequired() bool {
	return f.Required
}

// Int32Slice returns the []int32 value of the flag with the specified name.
func (c *Context) Int32Slice(name string) []int32 {
	value := c.lookup(name).GetValue()

	v, ok := value.([]int32)
	if !ok {
		panic(typeMismatchErr(name, "[]int32", value))
	}

	return v
}

var _ Flag = &Int64Flag{}

// Int64Flag is used to define a pflag.FlagSet.Int64P flag.
type Int64Flag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    int64
	Required bool
}

// Apply implements Flag.
func (f *Int64Flag) Apply(fs *pflag.FlagSet) {
	fs.Int64VarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Int64Flag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Int64Flag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Int64Flag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Int64Flag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Int64Flag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Int64Flag) IsRequired() bool {
	return f.Required
}

// Int64 returns the int64 value of the flag with the specified name.
func (c *Context) Int64(name string) int64 {
	value := c.lookup(name).GetValue()

	v, ok := value.(int64)
	if !ok {
		panic(typeMismatchErr(name, "int64", value))
	}

	return v
}

var _ Flag = &Int64SliceFlag{}

// Int64SliceFlag is used to define a pflag.FlagSet.Int64SliceP flag.
type Int64SliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []int64
	Required bool
}

// Apply implements Flag.
func (f *Int64SliceFlag) Apply(fs *pflag.FlagSet) {
	fs.Int64SliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *Int64SliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *Int64SliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *Int64SliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *Int64SliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *Int64SliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *Int64SliceFlag) IsRequired() bool {
	return f.Required
}

// Int64Slice returns the []int64 value of the flag with the specified name.
func (c *Context) Int64Slice(name string) []int64 {
	value := c.lookup(name).GetValue()

	v, ok := value.([]int64)
	if !ok {
		panic(typeMismatchErr(name, "[]int64", value))
	}

	return v
}

var _ Flag = &IntSliceFlag{}

// IntSliceFlag is used to define a pflag.FlagSet.IntSliceP flag.
type IntSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []int
	Required bool
}

// Apply implements Flag.
func (f *IntSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.IntSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IntSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IntSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IntSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IntSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IntSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IntSliceFlag) IsRequired() bool {
	return f.Required
}

// IntSlice returns the []int value of the flag with the specified name.
func (c *Context) IntSlice(name string) []int {
	value := c.lookup(name).GetValue()

	v, ok := value.([]int)
	if !ok {
		panic(typeMismatchErr(name, "[]int", value))
	}

	return v
}

var _ Flag = &StringFlag{}

// StringFlag is used to define a pflag.FlagSet.StringP flag.
type StringFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    string
	Required bool
}

// Apply implements Flag.
func (f *StringFlag) Apply(fs *pflag.FlagSet) {
	fs.StringVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *StringFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *StringFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *StringFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *StringFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *StringFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *StringFlag) IsRequired() bool {
	return f.Required
}

// String returns the string value of the flag with the specified name.
func (c *Context) String(name string) string {
	value := c.lookup(name).GetValue()

	v, ok := value.(string)
	if !ok {
		panic(typeMismatchErr(name, "string", value))
	}

	return v
}

var _ Flag = &StringSliceFlag{}

// StringSliceFlag is used to define a pflag.FlagSet.StringSliceP flag.
type StringSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []string
	Required bool
}

// Apply implements Flag.
func (f *StringSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.StringSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *StringSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *StringSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *StringSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *StringSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *StringSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *StringSliceFlag) IsRequired() bool {
	return f.Required
}

// StringSlice returns the []string value of the flag with the specified name.
func (c *Context) StringSlice(name string) []string {
	value := c.lookup(name).GetValue()

	v, ok := value.([]string)
	if !ok {
		panic(typeMismatchErr(name, "[]string", value))
	}

	return v
}

var _ Flag = &UintFlag{}

// UintFlag is used to define a pflag.FlagSet.UintP flag.
type UintFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    uint
	Required bool
}

// Apply implements Flag.
func (f *UintFlag) Apply(fs *pflag.FlagSet) {
	fs.UintVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *UintFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *UintFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *UintFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *UintFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *UintFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *UintFlag) IsRequired() bool {
	return f.Required
}

// Uint returns the uint value of the flag with the specified name.
func (c *Context) Uint(name string) uint {
	value := c.lookup(name).GetValue()

	v, ok := value.(uint)
	if !ok {
		panic(typeMismatchErr(name, "uint", value))
	}

	return v
}

var _ Flag = &UintSliceFlag{}

// UintSliceFlag is used to define a pflag.FlagSet.UintSliceP flag.
type UintSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []uint
	Required bool
}

// Apply implements Flag.
func (f *UintSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.UintSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *UintSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *UintSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *UintSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *UintSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *UintSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *UintSliceFlag) IsRequired() bool {
	return f.Required
}

// UintSlice returns the []uint value of the flag with the specified name.
func (c *Context) UintSlice(name string) []uint {
	value := c.lookup(name).GetValue()

	v, ok := value.([]uint)
	if !ok {
		panic(typeMismatchErr(name, "[]uint", value))
	}

	return v
}
