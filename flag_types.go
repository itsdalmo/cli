package cli

// Code generated by go generate; DO NOT EDIT.

import (
	"time"

	"github.com/spf13/pflag"
)

var _ Flag = &BoolFlag{}

// BoolFlag is used to define a pflag.FlagSet.BoolP flag.
type BoolFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    bool
	Required bool
}

// Apply implements Flag.
func (f *BoolFlag) Apply(fs *pflag.FlagSet) {
	fs.BoolVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *BoolFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *BoolFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *BoolFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *BoolFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *BoolFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *BoolFlag) IsRequired() bool {
	return f.Required
}

// Bool returns the bool value of the flag with the specified name.
func (c *Context) Bool(name string) bool {
	value := c.lookup(name).GetValue()

	v, ok := value.(bool)
	if !ok {
		panic(typeMismatchErr(name, "bool", value))
	}

	return v
}

var _ Flag = &BoolSliceFlag{}

// BoolSliceFlag is used to define a pflag.FlagSet.BoolSliceP flag.
type BoolSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []bool
	Required bool
}

// Apply implements Flag.
func (f *BoolSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.BoolSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *BoolSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *BoolSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *BoolSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *BoolSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *BoolSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *BoolSliceFlag) IsRequired() bool {
	return f.Required
}

// BoolSlice returns the []bool value of the flag with the specified name.
func (c *Context) BoolSlice(name string) []bool {
	value := c.lookup(name).GetValue()

	v, ok := value.([]bool)
	if !ok {
		panic(typeMismatchErr(name, "[]bool", value))
	}

	return v
}

var _ Flag = &DurationFlag{}

// DurationFlag is used to define a pflag.FlagSet.DurationP flag.
type DurationFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    time.Duration
	Required bool
}

// Apply implements Flag.
func (f *DurationFlag) Apply(fs *pflag.FlagSet) {
	fs.DurationVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *DurationFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *DurationFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *DurationFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *DurationFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *DurationFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *DurationFlag) IsRequired() bool {
	return f.Required
}

// Duration returns the time.Duration value of the flag with the specified name.
func (c *Context) Duration(name string) time.Duration {
	value := c.lookup(name).GetValue()

	v, ok := value.(time.Duration)
	if !ok {
		panic(typeMismatchErr(name, "time.Duration", value))
	}

	return v
}

var _ Flag = &DurationSliceFlag{}

// DurationSliceFlag is used to define a pflag.FlagSet.DurationSliceP flag.
type DurationSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []time.Duration
	Required bool
}

// Apply implements Flag.
func (f *DurationSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.DurationSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *DurationSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *DurationSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *DurationSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *DurationSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *DurationSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *DurationSliceFlag) IsRequired() bool {
	return f.Required
}

// DurationSlice returns the []time.Duration value of the flag with the specified name.
func (c *Context) DurationSlice(name string) []time.Duration {
	value := c.lookup(name).GetValue()

	v, ok := value.([]time.Duration)
	if !ok {
		panic(typeMismatchErr(name, "[]time.Duration", value))
	}

	return v
}

var _ Flag = &IntFlag{}

// IntFlag is used to define a pflag.FlagSet.IntP flag.
type IntFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    int
	Required bool
}

// Apply implements Flag.
func (f *IntFlag) Apply(fs *pflag.FlagSet) {
	fs.IntVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IntFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IntFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IntFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IntFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IntFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IntFlag) IsRequired() bool {
	return f.Required
}

// Int returns the int value of the flag with the specified name.
func (c *Context) Int(name string) int {
	value := c.lookup(name).GetValue()

	v, ok := value.(int)
	if !ok {
		panic(typeMismatchErr(name, "int", value))
	}

	return v
}

var _ Flag = &IntSliceFlag{}

// IntSliceFlag is used to define a pflag.FlagSet.IntSliceP flag.
type IntSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []int
	Required bool
}

// Apply implements Flag.
func (f *IntSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.IntSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *IntSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *IntSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *IntSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *IntSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *IntSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *IntSliceFlag) IsRequired() bool {
	return f.Required
}

// IntSlice returns the []int value of the flag with the specified name.
func (c *Context) IntSlice(name string) []int {
	value := c.lookup(name).GetValue()

	v, ok := value.([]int)
	if !ok {
		panic(typeMismatchErr(name, "[]int", value))
	}

	return v
}

var _ Flag = &StringFlag{}

// StringFlag is used to define a pflag.FlagSet.StringP flag.
type StringFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    string
	Required bool
}

// Apply implements Flag.
func (f *StringFlag) Apply(fs *pflag.FlagSet) {
	fs.StringVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *StringFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *StringFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *StringFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *StringFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *StringFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *StringFlag) IsRequired() bool {
	return f.Required
}

// String returns the string value of the flag with the specified name.
func (c *Context) String(name string) string {
	value := c.lookup(name).GetValue()

	v, ok := value.(string)
	if !ok {
		panic(typeMismatchErr(name, "string", value))
	}

	return v
}

var _ Flag = &StringSliceFlag{}

// StringSliceFlag is used to define a pflag.FlagSet.StringSliceP flag.
type StringSliceFlag struct {
	Name     string
	Usage    string
	EnvVar   []string
	Value    []string
	Required bool
}

// Apply implements Flag.
func (f *StringSliceFlag) Apply(fs *pflag.FlagSet) {
	fs.StringSliceVarP(&f.Value, f.GetName(), f.GetShorthand(), f.Value, usageWithEnvVar(f.GetUsage(), f.GetEnvVar()))
}

// GetName implements Flag.
func (f *StringSliceFlag) GetName() string {
	s, _ := splitFlagName(f.Name)
	return s
}

// GetShorthand implements Flag.
func (f *StringSliceFlag) GetShorthand() string {
	_, s := splitFlagName(f.Name)
	return s
}

// GetUsage implements Flag.
func (f *StringSliceFlag) GetUsage() string {
	return f.Usage
}

// GetEnvVar implements Flag.
func (f *StringSliceFlag) GetEnvVar() []string {
	return f.EnvVar
}

// GetValue implements Flag.
func (f *StringSliceFlag) GetValue() interface{} {
	return f.Value
}

// IsRequired implements Flag.
func (f *StringSliceFlag) IsRequired() bool {
	return f.Required
}

// StringSlice returns the []string value of the flag with the specified name.
func (c *Context) StringSlice(name string) []string {
	value := c.lookup(name).GetValue()

	v, ok := value.([]string)
	if !ok {
		panic(typeMismatchErr(name, "[]string", value))
	}

	return v
}
